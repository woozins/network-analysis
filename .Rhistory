### 데이터불러오기 ####################################################################################################################3
rm(list = ls())
library(readr)
library(readr)
library(igraph)
library(readxl)
library(dplyr)
seoul_2019 <- read_csv('dataset/seoul_movement_2019.csv')
seoul_2020 <- read_csv('dataset/seoul_movement_2020.csv')
seoul_2019 <- read_csv('network/dataset/seoul_movement_2019.csv')
seoul_2019 <- read_csv('network/dataset/seoul_movement_2019.csv')
seoul_2020 <- read_csv('network/dataset/seoul_movement_2020.csv')
seoul_2021 <- read_csv('network/dataset/seoul_movement_2021.csv')
seoul_2022 <- read_csv('network/dataset/seoul_movement_2022.csv')
seoul_2023 <- read_csv('network/dataset/seoul_movement_2023.csv')
seoul_2024 <- read_csv('network/dataset/seoul_movement_2024.csv')
data_seoul = list(seoul_2019, seoul_2020, seoul_2021, seoul_2022, seoul_2023,  seoul_2024)
edges_list <- data_seoul
g_weighted_list_seoul <- list()
for (edges in edges_list){
colnames(edges) <- c('from','to','weight')
g_weighted_list_seoul <- append(g_weighted_list_seoul, list(graph_from_data_frame(edges, directed = TRUE)))
}
# get adjacency matrix
adj_list_seoul <- list()
for (g in g_weighted_list_seoul){
adj_list_seoul <- append(adj_list_seoul, list(as_adjacency_matrix(g, attr = "weight", sparse = FALSE)))
}
adj_list_seoul
# pop list 필요하다 !!! 일단 오늘은 그대로 하장
pop2019 <- read_excel("dataset/2019_2019_주민등록 인구 기타현황(아동청소년청년 인구현황)_연간.xlsx", skip = 3)
pop2020 <- read_excel("dataset/2020_2020_주민등록 인구 기타현황(아동청소년청년 인구현황)_연간.xlsx", skip = 3)
# pop list 필요하다 !!! 일단 오늘은 그대로 하장
pop2019 <- read_excel("network/dataset/2019_2019_주민등록 인구 기타현황(아동청소년청년 인구현황)_연간.xlsx", skip = 3)
pop2020 <- read_excel("network/dataset/2020_2020_주민등록 인구 기타현황(아동청소년청년 인구현황)_연간.xlsx", skip = 3)
pop2021 <- read_excel("network/dataset/2021_2021_주민등록 인구 기타현황(아동청소년청년 인구현황)_연간.xlsx", skip = 3)
pop2022 <- read_excel("network/dataset/2022_2022_주민등록 인구 기타현황(아동청소년청년 인구현황)_연간.xlsx", skip = 3)
pop2023 <- read_excel("network/dataset/2023_2023_주민등록 인구 기타현황(아동청소년청년 인구현황)_연간.xlsx", skip = 3)
pop2024 <- read_excel("network/dataset/2024_2024_주민등록 인구 기타현황(아동청소년청년 인구현황)_연간.xlsx", skip = 3)
pop_data <- list(pop2019, pop2020, pop2021, pop2022, pop2023, pop2024)
pop_data
pop_list <- list()
for (data in pop_data){
temp <- data[,c(2,3)]
colnames(temp) <- c('gu', 'pop')
temp <- temp %>% mutate(gu = sapply(strsplit(gu, " "), function(x) x[2]), pop = as.numeric(gsub(",", "", pop)))
pop_list <- append(pop_list, list(temp))
}
length(adj_list_seoul)
adj_adj_list_seoul <- list()
for (i in seq(1:length(adj_list_seoul))){
adj <- adj_list_seoul[[i]]
pop <- pop_list[[i]]
temp <- left_join(cbind(as_tibble(adj), colnames(adj)), pop, by = c('colnames(adj)' ='gu'))
denominator <- temp[,ncol(temp)]
adj_adj <- as.matrix(sweep(adj, 1, denominator, '/')*100*1000) #percent/1000 단위로
storage.mode(adj_adj) <- 'integer'
adj_adj_list_seoul <- append(adj_adj_list_seoul, list(adj_adj))
}
# via cmdstan
library(cmdstanr)
install.packages('cmdstanr')
### 데이터불러오기 ####################################################################################################################3
rm(list = ls())
library(readr)
library(igraph)
library(readxl)
library(dplyr)
seoul_2019 <- read_csv('network/dataset/seoul_movement_2019.csv')
seoul_2020 <- read_csv('network/dataset/seoul_movement_2020.csv')
seoul_2021 <- read_csv('network/dataset/seoul_movement_2021.csv')
seoul_2022 <- read_csv('network/dataset/seoul_movement_2022.csv')
seoul_2023 <- read_csv('network/dataset/seoul_movement_2023.csv')
seoul_2024 <- read_csv('network/dataset/seoul_movement_2024.csv')
data_seoul = list(seoul_2019, seoul_2020, seoul_2021, seoul_2022, seoul_2023,  seoul_2024)
edges_list <- data_seoul
g_weighted_list_seoul <- list()
for (edges in edges_list){
colnames(edges) <- c('from','to','weight')
g_weighted_list_seoul <- append(g_weighted_list_seoul, list(graph_from_data_frame(edges, directed = TRUE)))
}
# get adjacency matrix
adj_list_seoul <- list()
for (g in g_weighted_list_seoul){
adj_list_seoul <- append(adj_list_seoul, list(as_adjacency_matrix(g, attr = "weight", sparse = FALSE)))
}
adj_list_seoul
# pop list 필요하다 !!! 일단 오늘은 그대로 하장
pop2019 <- read_excel("network/dataset/2019_2019_주민등록 인구 기타현황(아동청소년청년 인구현황)_연간.xlsx", skip = 3)
pop2020 <- read_excel("network/dataset/2020_2020_주민등록 인구 기타현황(아동청소년청년 인구현황)_연간.xlsx", skip = 3)
pop2021 <- read_excel("network/dataset/2021_2021_주민등록 인구 기타현황(아동청소년청년 인구현황)_연간.xlsx", skip = 3)
pop2022 <- read_excel("network/dataset/2022_2022_주민등록 인구 기타현황(아동청소년청년 인구현황)_연간.xlsx", skip = 3)
pop2023 <- read_excel("network/dataset/2023_2023_주민등록 인구 기타현황(아동청소년청년 인구현황)_연간.xlsx", skip = 3)
pop2024 <- read_excel("network/dataset/2024_2024_주민등록 인구 기타현황(아동청소년청년 인구현황)_연간.xlsx", skip = 3)
pop_data <- list(pop2019, pop2020, pop2021, pop2022, pop2023, pop2024)
pop_data
pop_list <- list()
for (data in pop_data){
temp <- data[,c(2,3)]
colnames(temp) <- c('gu', 'pop')
temp <- temp %>% mutate(gu = sapply(strsplit(gu, " "), function(x) x[2]), pop = as.numeric(gsub(",", "", pop)))
pop_list <- append(pop_list, list(temp))
}
length(adj_list_seoul)
adj_adj_list_seoul <- list()
for (i in seq(1:length(adj_list_seoul))){
adj <- adj_list_seoul[[i]]
pop <- pop_list[[i]]
temp <- left_join(cbind(as_tibble(adj), colnames(adj)), pop, by = c('colnames(adj)' ='gu'))
denominator <- temp[,ncol(temp)]
adj_adj <- as.matrix(sweep(adj, 1, denominator, '/')*100*1000) #percent/1000 단위로
storage.mode(adj_adj) <- 'integer'
adj_adj_list_seoul <- append(adj_adj_list_seoul, list(adj_adj))
}
# we need adjusted adjacent matrix
# adjusted adjacent matrix for 2024
library(readxl)
#1. stochastic block model : poisson_sbm
library(blockmodels)
options(bitmapType = "cairo")  # 그래픽 장치 오류 방지
bm_list <- list()
gof_list <- list()
for (adj_adj in adj_adj_list_seoul){
bm <- BM_poisson("SBM", adj_adj, explore_min = 4, explore_max = 10)
bm$estimate()
bm_list <- append(bm_list, list(bm))
gof_list <- append(evaluateModelFit(bm))
}
#1. stochastic block model : poisson_sbm
library(blockmodels)
options(bitmapType = "cairo")  # 그래픽 장치 오류 방지
bm_list <- list()
gof_list <- list()
for (adj_adj in adj_adj_list_seoul){
bm <- BM_poisson("SBM", adj_adj, explore_min = 4, explore_max = 10)
bm$estimate()
bm_list <- append(bm_list, list(bm))
gof_list <- append(evaluateModelFit(bm))
}
for (adj_adj in adj_adj_list_seoul){
bm <- BM_poisson("SBM", adj_adj, explore_min = 4, explore_max = 10)
bm$estimate()
bm_list <- append(bm_list, list(bm))
}
# ICL이 계속해서 증가. Elbow point 찾기.
for (bm in bm_list){
icls <- cbind(c(1:10), bm$ICL)
line <- function(x){
vec <- icls[nrow(icls), ] - icls[1,]
grad <- vec[2]/vec[1]
return(grad*(x-icls[1,1]) + icls[1,2])
}
# k 차이 순은 직선과의 거리 순
k <- icls[,2] - line(c(1:10))
K <- which.max(k)
print(K)
}
# get memberships
membership_list <- list()
for(i in seq_along(bm_list)){
sbm_result <- bm_list[[i]]
memberships <- cbind(rownames(adj_adj_list_seoul[[i]]), apply(sbm_result$memberships[[5]]$Z, 1, which.max))
membership_list <- append(membership_list, list(memberships))
}
# get memberships
membership_list <- list()
for(i in seq_along(bm_list)){
sbm_result <- bm_list[[i]]
memberships <- cbind(rownames(adj_adj_list_seoul[[i]]), apply(sbm_result$memberships[[5]]$Z, 1, which.max))
membership_list <- append(membership_list, list(memberships))
}
adj_adj_list_seoul <- list()
for (i in seq(1:length(adj_list_seoul))){
adj <- adj_list_seoul[[i]]
pop <- pop_list[[i]]
temp <- left_join(cbind(as_tibble(adj), colnames(adj)), pop, by = c('colnames(adj)' ='gu'))
denominator <- temp[,ncol(temp)]
adj_adj <- as.matrix(sweep(adj, 1, denominator, '/')*100*1000) #percent/1000 단위로
storage.mode(adj_adj) <- 'integer'
adj_adj_list_seoul <- append(adj_adj_list_seoul, list(adj_adj))
}
#1. stochastic block model : poisson_sbm
library(blockmodels)
options(bitmapType = "cairo")  # 그래픽 장치 오류 방지
bm_list <- list()
gof_list <- list()
for (adj_adj in adj_adj_list_seoul){
bm <- BM_poisson("SBM", adj_adj, explore_min = 4, explore_max = 10)
bm$estimate()
bm_list <- append(bm_list, list(bm))
}
# ICL이 계속해서 증가. Elbow point 찾기.
for (bm in bm_list){
icls <- cbind(c(1:10), bm$ICL)
line <- function(x){
vec <- icls[nrow(icls), ] - icls[1,]
grad <- vec[2]/vec[1]
return(grad*(x-icls[1,1]) + icls[1,2])
}
# k 차이 순은 직선과의 거리 순
k <- icls[,2] - line(c(1:10))
K <- which.max(k)
print(K)
}
# get memberships
membership_list <- list()
for(i in seq_along(bm_list)){
sbm_result <- bm_list[[i]]
memberships <- cbind(rownames(adj_adj_list_seoul[[i]]), apply(sbm_result$memberships[[5]]$Z, 1, which.max))
membership_list <- append(membership_list, list(memberships))
}
# via cmdstan
library(cmdstanr)
install.packages('cmdstanr')
install.packages("remotes")  # 먼저 설치
remotes::install_github("stan-dev/cmdstanr", dependencies = TRUE)
# via cmdstan
library(cmdstanr)
install_cmdstan()
mod <- cmdstan_model("stan/ldm_poisson.stan")
getwd()
mod <- cmdstan_model("network/stan/ldm_poisson.stan")
adj
adj_adj_list_seoul
adj_adj_list_seoul[[6]]
mat <- adj_adj_list_seoul[[6]]
stan_data <- list(N = 25, Y = mat)
stan_data$Y
fit <- mod$sample(
data = stan_data,
seed = 123,
chains = 3,
parallel_chains = 6,
iter_warmup = 10000,
iter_sampling = 50000
)
#model summary
library(posterior)
library(bayesplot)
library(Cairo)
library(ggplot2)
draws <- fit$draws()
summary <- summarise_draws(draws)
summary$mean
summary
print(summary$variable, n = 100)
summary$variable
grid <- matrix(summary$mean[51:100], ncol = 2)
grid
grid_data <- as.data.frame(cbind(grid, rownames(stan_data$Y)))
colnames(grid_data) <- c('x','y', 'node')
grid_data$x <- as.numeric(grid_data$x)
grid_data$y <- as.numeric(grid_data$y)
grid_data$membership <- as.factor(memberships[,2])
grid_data
savegraph <- paste0('plots/ldm', format(Sys.time(), "%d-%H-%M-%S"),'.png')
CairoPNG(savegraph, width=1200, height=300 * dim(draws)[2])
ggplot(data = grid_data)+
geom_point(aes(x =x, y = y, color = membership))
dev.off()
savegraph <- paste0('network/plots/ldm', format(Sys.time(), "%d-%H-%M-%S"),'.png')
CairoPNG(savegraph, width=1200, height=300 * dim(draws)[2])
ggplot(data = grid_data)+
geom_point(aes(x =x, y = y, color = membership))
dev.off()
grid_data <- grid_data %>%
mutate(membership = recode(membership,
"1" = "서북권",
"2" = "도심권",
"3" = "서남권",
"4" = "동남권",
"5" = "동북권"))
grid_data
savegraph <- paste0('network/plots/ldm', format(Sys.time(), "%d-%H-%M-%S"),'.png')
CairoPNG(savegraph, width=1200, height=300 * dim(draws)[2])
ggplot(data = grid_data)+
geom_point(aes(x =x, y = y, color = membership))
dev.off()
to_csv(grid_data, 'grid_data.csv')
savev(grid_data, 'grid_data.csv')
save(grid_data, 'grid_data.csv')
write.csv(grid_data, 'grid_data.csv')
#데이터 불러오기 / 기본적 분석################33################################################################################################
rm(list = ls())
library(igraph)
library(readxl)
library(dplyr)
library(readr)
# young_2014 <- read_csv("dataset/청년_구간_이동_전입자수_2014.csv")
young_2019 <- read_csv("dataset/청년_구간_이동_전입자수_2019.csv")
young_2020 <- read_csv("dataset/청년_구간_이동_전입자수_2020.csv")
young_2021 <- read_csv("dataset/청년_구간_이동_전입자수_2021.csv")
young_2022 <- read_csv("dataset/청년_구간_이동_전입자수_2022.csv")
young_2023 <- read_csv("dataset/청년_구간_이동_전입자수_2023.csv")
getwd()
chdir("/home/cowzin/network.network")
setwd("/home/cowzin/network.network")
setwd("/home/cowzin/network/network")
library(igraph)
library(readxl)
library(dplyr)
library(readr)
# young_2014 <- read_csv("dataset/청년_구간_이동_전입자수_2014.csv")
young_2019 <- read_csv("dataset/청년_구간_이동_전입자수_2019.csv")
young_2020 <- read_csv("dataset/청년_구간_이동_전입자수_2020.csv")
young_2021 <- read_csv("dataset/청년_구간_이동_전입자수_2021.csv")
young_2022 <- read_csv("dataset/청년_구간_이동_전입자수_2022.csv")
young_2023 <- read_csv("dataset/청년_구간_이동_전입자수_2023.csv")
young_2024 <- read_csv("dataset/청년_구간_이동_전입자수_2024.csv")
data_young = list(young_2019, young_2020, young_2021, young_2022, young_2023,  young_2024)
edges_list <- data_young
g_weighted_list_young <- list()
for (edges in edges_list){
colnames(edges) <- c('from','to','weight')
g_weighted_list_young <- append(g_weighted_list_young, list(graph_from_data_frame(edges, directed = TRUE)))
}
# get adjacency matrix
adj_list_young <- list()
for (g in g_weighted_list_young){
adj_list_young <- append(adj_list_young, list(as_adjacency_matrix(g, attr = "weight", sparse = FALSE)))
}
# 수정된 adjacency matrix
# pop list 필요하다 !!! 일단 오늘은 그대로 하장
pop2019 <- read_excel("dataset/2019_2019_주민등록 인구 기타현황(아동청소년청년 인구현황)_연간.xlsx", skip = 3)
pop2020 <- read_excel("dataset/2020_2020_주민등록 인구 기타현황(아동청소년청년 인구현황)_연간.xlsx", skip = 3)
pop2021 <- read_excel("dataset/2021_2021_주민등록 인구 기타현황(아동청소년청년 인구현황)_연간.xlsx", skip = 3)
pop2022 <- read_excel("dataset/2022_2022_주민등록 인구 기타현황(아동청소년청년 인구현황)_연간.xlsx", skip = 3)
pop2023 <- read_excel("dataset/2023_2023_주민등록 인구 기타현황(아동청소년청년 인구현황)_연간.xlsx", skip = 3)
pop2024 <- read_excel("dataset/2024_2024_주민등록 인구 기타현황(아동청소년청년 인구현황)_연간.xlsx", skip = 3)
pop_data <- list(pop2019, pop2020, pop2021, pop2022, pop2023, pop2024)
pop_list <- list()
for (data in pop_data){
temp <- data[,c(2,12)]
colnames(temp) <- c('gu', 'pop')
temp <- temp %>% mutate(gu = sapply(strsplit(gu, " "), function(x) x[2]), pop = as.numeric(gsub(",", "", pop)))
pop_list <- append(pop_list, list(temp))
}
adj_adj_list_young <- list()
for (i in seq(1:length(adj_list_young))){
adj <- adj_list_young[[i]]
pop <- pop_list[[i]]
temp <- left_join(cbind(as_tibble(adj), colnames(adj)), pop, by = c('colnames(adj)' ='gu'))
denominator <- temp[,ncol(temp)]
adj_adj <- as.matrix(sweep(adj, 1, denominator, '/')*100*1000) #percent/1000 단위로
storage.mode(adj_adj) <- 'integer'
adj_adj_list_young <- append(adj_adj_list_young, list(adj_adj))
}
adj_adj_list_young
#1. stochastic block model : poisson_sbm
library(blockmodels)
library(sbm)
bm_list <- list()
for (adj_adj in adj_adj_list_young){
bm <- BM_poisson("SBM", adj_adj, explore_min = 4, explore_max = 10)
bm$estimate()
bm_list <- append(bm_list, list(bm))
}
# ICL이 계속해서 증가. Elbow point 찾기.
for (bm in bm_list){
icls <- cbind(c(1:10), bm$ICL)
line <- function(x){
vec <- icls[nrow(icls), ] - icls[1,]
grad <- vec[2]/vec[1]
return(grad*(x-icls[1,1]) + icls[1,2])
}
# k 차이 순은 직선과의 거리 순
k <- icls[,2] - line(c(1:10))
K <- which.max(k)
print(K)
}
# get memberships
membership_list <- list()
for(i in seq_along(bm_list)){
sbm_result <- bm_list[[i]]
memberships <- cbind(rownames(adj_adj_list_young[[i]]), apply(sbm_result$memberships[[5]]$Z, 1, which.max))
membership_list <- append(membership_list, list(memberships))
}
mat <-
mod <- cmdstan_model("stan/ldm_poisson.stan")
adj_adj_list_young
mat <- adj_adj_list_young[[6]]
mod <- cmdstan_model("stan/ldm_poisson.stan")
# via cmdstan
library(cmdstanr)
mat <- adj_adj_list_young[[6]]
mod <- cmdstan_model("stan/ldm_poisson.stan")
mod <- cmdstan_model("network/stan/ldm_poisson.stan")
# via cmdstan
library(cmdstanr)
mat <- adj_adj_list_young[[6]]
mod <- cmdstan_model("network/stan/ldm_poisson.stan")
mod <- cmdstan_model("network/stan/ldm_poisson.stan")
# via cmdstan
getwd()
mod <- cmdstan_model("stan/ldm_poisson.stan")
mod <- cmdstan_model("stan/ldm_poisson.stan", force_recompile = TRUE)
stan_data <- list(N = 25, Y = mat)
stan_data$Y
fit <- mod$sample(
data = stan_data,
seed = 123,
chains = 3,
parallel_chains = 6,
iter_warmup = 10000,
iter_sampling = 50000
)
draws <- fit$draws()
summary <- summarise_draws(draws)
grid <- matrix(summary$mean[51:100], ncol = 2)
grid
grid_data <- as.data.frame(cbind(grid, rownames(stan_data$Y)))
colnames(grid_data) <- c('x','y', 'node')
grid_data$x <- as.numeric(grid_data$x)
grid_data$y <- as.numeric(grid_data$y)
grid_data$membership <- as.factor(memberships[,2])
grid_data
grid_data <- grid_data %>%
mutate(membership = recode(membership,
"1" = "1번",
"2" = "2번",
"3" = "3번",
"4" = "4번",
"5" = "5번"))
write.csv(grid_data, 'young_grid_data.csv')
grid_data
